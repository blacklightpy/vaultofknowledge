First, we must have a vision. I'm not yet talking about whether it should be big or small. But there should be a vision, nevertheless.

Then, we must find a way to create it from the ideas we already know. I know that's simple to say, but I'm not finished yet, I'll expand on it.

So, if our current understanding does not let us create it, we will have to refine our understanding itself. The field of endeavour that seeks such an understanding is called science, and when our knowledge is classified, it becomes part of a scientific discipline.

But I'll focus more on creating something from the ideas that we already know of.
# The main problem
So we now know that we have to have a vision and also eventually build it, or manifest it into the concrete world.

But where do we start from? Do we start from the vision and try to fit it into the world, or do we start from the basic components, and hope for the path we take to lead to the vision?

Colloquially, this is known as the problem of looking at the trees vs the forest. A good architect, although he may have a preference, must eventually come to do both.

Starting from the basic blocks is known as the **bottom-up** approach. Starting from the vision and filling in the details is known as the **top-down** approach.

...

---

- Jyothish, raise the bar for tolerance
	- A Java implementation can be inefficient relative to a C++ implementation
		- But a poor C++ implementation will be outperformed by a good Java implementation
	- However, having a Java implementation is better than not having a implementation
	- So let us first tolerate weak implementations to foster ideas, then optimize it
	
	- This optimization should not be done in such a way that the resulting program will end up being less customizable. That is, instead of converting a Lua program to C++, make a compiler that would efficiently convert the Lua implementation to C++. Also (I'm only using Lua as an example here), make sure that Lua is designed to provide a specific format of design workflow, by which you will always end up designing good programs.

1. Story of the White bird.
2. 
   - What we need
	   - Compute
		   - Integer
		   - Floating Point
		   - Parallel Compute (Approximate)
		   - Parallel Compute (Precise)
	   - Outputs
		   - Vision
			   - Driver (e.g. Kernel Mode Setting, Kernel Video Module)
			   - Simple (Single Output, e.g. Framebuffer, DRI)
			   - Composited (Window Management, e.g. minimal X or Wayland compositors)
			   - Composited with Routing (Multi-screen setups, e.g. X or Wayland compositors, DWM)
			   - Advanced (e.g. Compiz, HackMatrix)
		   - Sonic
			   - Driver (e.g. ALSA, Windows audio driver)
			   - Simple (e.g. ALSA API, Windows kernel audio interface)
			   - Composited (e.g. PulseAudio, WASAPI)
			   - Composited with Routing (e.g. JACK, PipeWire, ASIO)
			   - Advanced (e.g. Opus, Dolby Atmos, Dolby Digital, DTS-X, DTS)
	   - Components
		   - Vision
			   - Drawing Libraries (e.g. )
			   - Widgeting Toolkits

- Program
- Widget Frameworks/Toolkits: GTK, Qt
- Drawing Libraries: Cairo, Skia
- Widget Toolkit Backends: GDK, Qt/X11
- Display System APIs: XLib/XCB, libWayland
- Display System: X (Server + Client), Wayland Compositor
- Display System Backends: DDX (X), \<none\> (Wayland)
- Direct Drawing APIs: SDL2
- Graphics API: Mesa3D (Vulkan) + libDRM, NVIDIA
- Graphics Driver: DRM, NVIDIA
- GPU

GDI/Direct2D + DWM > Win32 API, 
